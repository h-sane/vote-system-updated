
// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';

const SUPABASE_URL = "https://sujnjgmzttjkostfjuyw.supabase.co";
const SUPABASE_PUBLISHABLE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InN1am5qZ216dHRqa29zdGZqdXl3Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDYzNjI3MzYsImV4cCI6MjA2MTkzODczNn0.yoeTJRaIdu4xwPx0-RUwBBjz5IGqGqxQ2qPlx3XqLOA";

// Import the supabase client like this:
// import { supabase } from "@/integrations/supabase/client";

export const supabase = createClient<Database>(SUPABASE_URL, SUPABASE_PUBLISHABLE_KEY);

// Add utility functions to work with the votes table
export const getElections = async () => {
  return await supabase
    .from('elections')
    .select(`
      *,
      candidates(*)
    `)
    .order('created_at', { ascending: false });
};

export const getElection = async (id: string) => {
  return await supabase
    .from('elections')
    .select(`
      *,
      candidates(*)
    `)
    .eq('id', id)
    .single();
};

export const castVote = async (
  voterId: string, 
  candidateId: string,
  electionId: string
) => {
  // Generate a temporary placeholder for vote_hash
  // The actual hash will be generated by the database trigger
  const placeholderHash = `temp_${Date.now().toString(36)}`;
  
  return await supabase
    .from('votes')
    .insert({
      voter_id: voterId,
      candidate_id: candidateId,
      election_id: electionId,
      vote_hash: placeholderHash // Add required vote_hash field with a placeholder
    });
};

export const getVoteResults = async (electionId: string) => {
  const { data: votes, error } = await supabase
    .from('votes')
    .select('candidate_id')
    .eq('election_id', electionId);
    
  if (error) throw error;
  
  // Count votes per candidate
  const voteCounts: Record<string, number> = {};
  votes?.forEach(vote => {
    voteCounts[vote.candidate_id] = (voteCounts[vote.candidate_id] || 0) + 1;
  });
  
  return voteCounts;
};

export const storeFingerprint = async (userId: string, fingerprintHash: string, deviceInfo?: any) => {
  return await supabase
    .from('users_biometrics')
    .upsert({
      user_id: userId,
      fingerprint_hash: fingerprintHash,
      device_info: deviceInfo,
      updated_at: new Date().toISOString()
    });
};

export const verifyFingerprint = async (userId: string, fingerprintHash: string) => {
  const { data, error } = await supabase
    .from('users_biometrics')
    .select('fingerprint_hash')
    .eq('user_id', userId)
    .single();
    
  if (error) return false;
  return data?.fingerprint_hash === fingerprintHash;
};

// Add audit logging functions
export const logAuditEvent = async (
  userId: string,
  action: string,
  details: any,
  ipAddress?: string,
  userAgent?: string
) => {
  return await supabase.rpc('log_audit_event', {
    _user_id: userId,
    _action: action,
    _details: details,
    _ip_address: ipAddress,
    _user_agent: userAgent
  });
};

// Get blockchain explorer data
export const getBlockchainData = async (electionId?: string) => {
  let query = supabase
    .from('votes')
    .select(`
      id,
      vote_hash,
      previous_hash,
      timestamp,
      voter_id,
      candidate_id,
      election_id
    `)
    .order('timestamp', { ascending: true });
    
  if (electionId) {
    query = query.eq('election_id', electionId);
  }
  
  return await query;
};
